;
; Replayer core to play vector encoded 44.1kHz samples generated by pcmenc
;
; pcmenc should use the following command line arguments:
;
; pcmenc -p 6 -rto 3 -dt1 81 -dt2 81 -dt3 82 file.wav
;
; and optionally -r to split sample into blocks for rom replayer
;

; There is one channel updates per underlying sample.
; We emit three channel updates, as evenly spaced as possible, looping
; every 244 cycles, to match an underlying sample at ~44010Hz
; (3579545 / 244 * 3 = 44010.8)

; We create some lookup tables for all the possible data values for both low and high nibbles.
; These must be 256-byte aligned and are ordered to match the outputs for a pair of triplets.
srl4_table_0:
  .repeat 256 index n
  .db (0 << 5) | $90 | (n>>4)
  .endr
lo4_table_1:
  .repeat 256 index n
  .db (1 << 5) | $90 | (n & $f)
  .endr
srl4_table_2:
  .repeat 256 index n
  .db (2 << 5) | $90 | (n>>4)
  .endr
lo4_table_0:
  .repeat 256 index n
  .db (0 << 5) | $90 | (n & $f)
  .endr
srl4_table_1:
  .repeat 256 index n
  .db (1 << 5) | $90 | (n>>4)
  .endr
lo4_table_2:
  .repeat 256 index n
  .db (2 << 5) | $90 | (n & $f)
  .endr

;-------------------------------------
; Plays one sample
; HL - points to data, must be aligned to 256 bytes
;-------------------------------------
PLAY_SAMPLE:
  ; hl points to the next sample index (source data)
  ; bc holds the sample count remaining to play
  ; hl' points to the vector tables
  ; de' points to the data -> PSG command lookup tables above
  ; b' is a copy of the initial value of h
  
  ; save high byte of hl to b' (we require l is zero)
  ld a,h
  exx
    ld b,a
  exx
  
  ; move to start of data
  inc h
  inc h
  inc h
  ; read counter
  ld c,(hl)
  inc hl
  ld b,(hl)
  inc hl
  
; Could try to optimise this for space, but why bother as we have 1.5KB of tables :)
.macro Delay args n
  .if n == 59
  call Delay59
  .else
  .if n == 49
  call Delay49
  .else
  .if n == 40
  call Delay40
  .else
  .fail "Unhandled delay"
  .endif
  .endif
  .endif
.endm

-:
                  ; 22 for loop
  nop             ; 4 - delay 8 cycles
  nop             ; 4
  ld a,(hl)       ; 7
  exx             ; 4
    ; Look up in table(s)
    ld l,a        ; 4
    ld h,b        ; 4
  
    ; Get byte from table (1/3)
    ld d,>srl4_table_0 ; 7
    ld e,(hl)     ; 7
    
    ; Emit first
    ld a,(de)     ; 7
    out ($7f),a    ; 11 -> 81 cycles

    ; Second
    Delay           59
    inc d         ; 4
    ld a,(de)     ; 7
    out ($7f),a    ; 11 -> 81
    
    ; Byte 2/3
    Delay           49
    inc h         ; 4
    inc d         ; 4
    ld e,(hl)     ; 7
    ld a,(de)     ; 7
    out ($7f),a    ; 11 -> 82
    
    Delay           59
    inc d         ; 4
    ld a,(de)     ; 7
    out ($7f),a    ; 11 -> 81

    ; Byte 3/3
    Delay           49
    inc h         ; 4
    inc d         ; 4
    ld e,(hl)     ; 7
    ld a,(de)     ; 7
    out ($7f),a    ; 11 -> 81
    
    Delay           40
    ; Loop work 
  exx             ; 4
  inc hl          ; 6
  dec bc          ; 6
  exx             ; 4
    inc d         ; 4
    ld a,(de)     ; 7
    out ($7f),a    ; 11 -> 82

  exx             ; 4
  ; check count 
  ld a,b          ; 4
  or c            ; 4
  jp nz,-         ; 10
  ret
  
Delay59:
  jp +    ; 10
Delay49:
+:ld a,i  ; 9
Delay40:
  ld a,(Delay40) ; 13
  ret     ; 27 for call and ret
  
